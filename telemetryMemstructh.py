
import sys
import os
from message_mod import message
from signal_mod import signal
from board_mod import boards

def generate(board_list):

	if os.path.exists("output/telemetry_memstruct.h"):
		try:
			os.remove("output/telemetry_memstruct.h")
		except:
			print("ERROR: Failed to remove telemetry_memstruct.h in output")
			sys.exit()
	
	with open("output/telemetry_memstruct.h", "w+") as fo:
		
		# Start with header generation
		str = f"/* This file was generated by EclipseMemstructGen.py*/\n\n"
		
		# Header guards
		str += (
			f"#ifndef TELEMETRY_MEMSTRUCT_H_\n"
			f"#define TELEMETRY_MEMSTRUCT_H_\n\n"
		)

		# includes and defines
		str += (
			f"#include <vector>\n"
			f"#include <algorithm>\n"
			f"#include <array>\n"
			f"#include <string_view>\n"
			f"using namespace std::literals::string_view_literals;\n"
			f"\n"
			f"#define CANFRM_EXTENDED_ID  (1<<29)\n"
			f"#define CANFRM_RTR          (1<<30)\n"
			f"\n"
			f"#define MAX_SIG_CNT 8\n"
			f"\n"
			f"#define L_ENDIAN 0\n"
			f"#define B_ENDIAN 1\n"
			f"\n"
		)

		# Data type descriptions enum
		str += (
			f"enum DATA_TYPE\n"
			f"{{\n"
			f"        TYPE_FLOATING = 0x10,\n"
			f"                TYPE_float,\n"
			f"                TYPE_double,\n"
			f"        TYPE_UNSIGNED = 0x20,\n"
			f"                TYPE_uint32_t,\n"
			f"                TYPE_uint16_t,\n"
			f"                TYPE_uint8_t,\n"
			f"        TYPE_SIGNED = 0x40,\n"
			f"                TYPE_int32_t,\n"
			f"                TYPE_int16_t,\n"
			f"                TYPE_int8_t\n"
			f"}};\n"
			f"\n"
		)
		
		# Generate Board Enum
		board_enum_str = ""
		for board in board_list:
			board_enum_str += board.print_enum()
		str += (
			f"/*Board enum*/\n"
			f"enum{{\n"
			f"{board_enum_str}"
			f"}};\n"
			f"\n"
		)

		# Generate Message List
		message_enum_str = ""
		for board in board_list:
			message_enum_str += board.print_header()
			message_enum_str += board.print_message_enum_telemetry()
		str += (
			f"/*Message enum*/\n"
			f"enum CAN_ID\n"
			f"{{\n"
			f"{message_enum_str}"
			f"}};\n"
			f"\n"
		)

		# Generate Signal List
		signal_enum_str = ""
		for board in board_list:
			signal_enum_str += board.print_header()
			signal_enum_str += board.print_signal_enum()
		str += (
			f"/*Signal enum*/\n"
			f"enum SIGNAL_ID\n"
			f"{{\n"
			f"{signal_enum_str}"
			f"\n"
			f"        NUM_SIGNAL_IDS\n"
			f"}};\n"
			f"\n"
		)

		# Defintion of Signal decode struct
		str += (
			f" /*  SignalDecode struct  */\n"
			f"struct SignalDecode\n"
			f"{{\n"
			f"        uint32_t id;\n"
			f"        std::string_view name;\n"
			f"        DATA_TYPE type;\n"
			f"        uint32_t byte_pos;\n"
			f"        uint32_t size;\n"
			f"        uint8_t endianness;\n"
			f"        float multiplier;\n"
			f"}};\n"
			f"\n"
		)
		
		# Defintion of CAN message decode struct
		str += (
			f" /*  MessageDecode struct  */\n"
			f"struct MessageDecode\n"
			f"{{\n"
			f"        uint32_t id;\n"
			f"        uint32_t pos;\n"
			f"        std::string_view name;\n"
			f"        uint32_t num_signals;\n"
			f"        SignalDecode signals[MAX_SIG_CNT];  /* Signals */\n"
			f"}};\n"
			f"\n"
		)

		# Get total number of CAN signals
		num_can_messages = 0
		for board in board_list:
			num_can_messages = num_can_messages + board.message_cnt
		
		# Signal full definition array
		message_def_str = ""
		for board in board_list:
			message_def_str += board.print_header()
			message_def_str += board.print_message_def_telemetry()
		str += (
			f"static constexpr std::array<std::pair<uint32_t, MessageDecode>, {num_can_messages}> CAN_MESSAGES \n"
			f"{{{{\n"
			f"{message_def_str}"
			f"}}}};\n"
			f"\n"
			f"\n"
		)
		
		# End header guard and close file
		str += f"#endif\n"
		
		# Writing to file
		fo.write(str)
