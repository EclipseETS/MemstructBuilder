

def generate(fname, board_list):
	
	with open(fname, "w") as fo:
		
		# Start with header generation
		final_output = f"/* This file was generated by EclipseMemstructGen.py*/\n\n"
		
		# Header guards
		final_output += (
			f"#ifndef TELEMETRY_MEMSTRUCT_H_\n"
			f"#define TELEMETRY_MEMSTRUCT_H_\n\n"
		)

		# includes and defines
		final_output += (
			f"#include <vector>\n"
			f"#include <algorithm>\n"
			f"#include <array>\n"
			f"#include <string_view>\n"
			f"using namespace std::literals::string_view_literals;\n"
			f"\n"
			f"#define CANFRM_EXTENDED_ID  (1<<29)\n"
			f"#define CANFRM_RTR          (1<<30)\n"
			f"\n"
			f"#define MAX_SIG_CNT 8\n"
			f"\n"
			f"#define L_ENDIAN 0\n"
			f"#define B_ENDIAN 1\n"
			f"\n"
		)

		# Data type descriptions enum
		final_output += (
			f"enum DATA_TYPE\n"
			f"{{\n"
			f"        TYPE_FLOATING = 0x10,\n"
			f"                TYPE_float,\n"
			f"                TYPE_double,\n"
			f"        TYPE_UNSIGNED = 0x20,\n"
			f"                TYPE_uint32_t,\n"
			f"                TYPE_uint16_t,\n"
			f"                TYPE_uint8_t,\n"
			f"        TYPE_SIGNED = 0x40,\n"
			f"                TYPE_int32_t,\n"
			f"                TYPE_int16_t,\n"
			f"                TYPE_int8_t\n"
			f"}};\n"
			f"\n"
		)
		
		# Generate Board Enum
		board_enums = []
		for board in board_list:
			board_enums.append(board.print_enum())
		board_enum_str = ',\n'.join(board_enums)
		final_output += (
			f"/*Board enum*/\n"
			f"enum{{\n"
			f"{board_enum_str}\n"
			f"}};\n"
			f"\n"
		)

		# Generate Message List
		message_enums = []
		for board in board_list:
			string = board.print_header()
			string += board.print_message_enum_telemetry()
			message_enums.append(string)
		message_enum_str = ',\n'.join(message_enums)
		final_output += (
			f"/*Message enum*/\n"
			f"enum CAN_ID\n"
			f"{{\n"
			f"{message_enum_str}\n"
			f"}};\n"
			f"\n"
		)

		# Generate Signal List
		signal_enums = []
		for board in board_list:
			string = board.print_header()
			string += board.print_signal_enum()
			signal_enums.append(string)
		signal_enum_str = ',\n'.join(signal_enums)
		final_output += (
			f"/*Signal enum*/\n"
			f"enum SIGNAL_ID\n"
			f"{{\n"
			f"{signal_enum_str},\n"
			f"\n"
			f"        NUM_SIGNAL_IDS\n"
			f"}};\n"
			f"\n"
		)

		# Defintion of Signal decode struct
		final_output += (
			f" /*  SignalDecode struct  */\n"
			f"struct SignalDecode\n"
			f"{{\n"
			f"        uint32_t id;\n"
			f"        std::string_view name;\n"
			f"        DATA_TYPE type;\n"
			f"        uint32_t byte_pos;\n"
			f"        uint32_t size;\n"
			f"        uint8_t endianness;\n"
			f"        float multiplier;\n"
			f"}};\n"
			f"\n"
		)
		
		# Defintion of CAN message decode struct
		final_output += (
			f" /*  MessageDecode struct  */\n"
			f"struct MessageDecode\n"
			f"{{\n"
			f"        uint32_t id;\n"
			f"        uint32_t pos;\n"
			f"        std::string_view name;\n"
			f"        uint32_t num_signals;\n"
			f"        SignalDecode signals[MAX_SIG_CNT];  /* Signals */\n"
			f"}};\n"
			f"\n"
		)

		# Get total number of CAN signals
		num_can_messages = 0
		for board in board_list:
			num_can_messages = num_can_messages + board.message_cnt
		
		# Signal full definition array
		message_defs = []
		for board in board_list:
			string = board.print_header()
			string += board.print_message_def_telemetry()
			message_defs.append(string)
		message_def_str = ',\n'.join(message_defs)
		final_output += (
			f"static constexpr std::array<std::pair<uint32_t, MessageDecode>, {num_can_messages}> CAN_MESSAGES \n"
			f"{{{{\n"
			f"{message_def_str}\n"
			f"}}}};\n"
			f"\n"
			f"\n"
		)
		
		# End header guard and close file
		final_output += f"#endif\n"
		
		# Writing to file
		fo.write(final_output)
